# Технологии индустриального программирования
|||
|---|---|
|Направление подготовки|09.03.02 "Информационные системы и технологии"|
|Профиль|Фуллстек разработка|
|Курс, семестр|1-2, 1-3 семестры|

Ссылка на репозиторий:

https://github.com/astafiev-rustam/industrial-programming-technologies/tree/practice-1-6

# Практическое занятие №6: Функции и процедуры. Рекурсия.

Если представить программу как фабрику, то функции — это цеха этой фабрики, каждый из которых выполняет свою конкретную задачу. Это не просто технический прием, а фундаментальный принцип, который позволяет создавать понятный, надежный и легко изменяемый код.

## Часть 1: Зачем нужны функции? Преодоление хаоса

Представьте, что вы пишете программу для интернет-магазина. В разных местах программы вам нужно проверять, достаточно ли средств на счете пользователя для совершения покупки. Без функций вам пришлось бы снова и снова копировать один и тот же блок кода с проверками, разбросав его по всей программе. Что произойдет, если требования к проверке изменятся? Вам придется найти и исправить каждую копию этого кода — это неэффективно и чревато ошибками.

Функции решают эту проблему, предлагая нам принцип «Не повторяйся». Мы оформляем повторяющийся код в виде отдельной функции и затем просто «вызываем» ее по имени, когда нам нужно выполнить соответствующее действие. Основные преимущества функций заключаются в структурировании кода, когда большая задача разбивается на маленькие логические подзадачи, в избежании дублирования, что делает код более компактным, в упрощении отладки, поскольку ошибку легче найти в одном конкретном месте, и в сокрытии сложности, позволяя использовать готовые решения без погружения в детали их внутренней работы.

## Часть 2: Функции и процедуры. Декомпозиция задачи

В C++ технически все подпрограммы являются функциями. Однако с концептуальной точки зрения мы можем разделить их на два типа. Функции в строгом смысле — это подпрограммы, которые принимают некоторые данные, обрабатывают их и возвращают результат. Например, функция `calculateSquareRoot(number)` принимает число и возвращает его корень. Процедуры — это подпрограммы, которые выполняют определенное действие, не возвращая значения. Их работа заключается в побочном эффекте, таком как вывод информации на экран, сохранение данных в файл или изменение глобальной переменной. В C++ процедура объявляется как функция с возвращаемым типом `void`, что как раз и означает «ничего».

## Часть 3: Анатомия функции. От объявления до вызова

Чтобы использовать функцию, нам нужно ее сначала объявить и определить. Объявление функции, также известное как прототип, знакомит компилятор с существованием функции. Оно сообщает компилятору, как функция будет называться, какие аргументы она ожидает и какой тип данных вернет. Прототип выглядит так: `тип_возвращаемого_значения имя_функции(тип1 аргумент1, тип2 аргумент2);`. Определение функции — это уже ее полное тело, та самая реализация, где описывается алгоритм. Оно включает в себя прототип и блок кода в фигурных скобках.

Рассмотрим пример функции, которая вычисляет факториал числа. Факториал числа n — это произведение всех целых чисел от 1 до n.

Сначала мы объявляем прототип: `int factorial(int n);`. Эта строка говорит компилятору: «будет функция с именем factorial, которая принимает целое число n и возвращает целое число».

Затем мы определяем саму функцию:
```cpp
int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result; // Ключевое слово return возвращает результат
}
```

И, наконец, мы вызываем эту функцию в main, передавая ей конкретное значение:
```cpp
int main() {
    int number = 5;
    int result = factorial(number); // Вызов функции. number — аргумент.
    cout << "Факториал числа " << number << " равен " << result << endl;
    return 0;
}
```

Когда программа доходит до строки `factorial(number)`, управление передается внутрь функции `factorial`. Выполняется ее код, и затем оператор `return` передает вычисленное значение обратно в то место, откуда функция была вызвана. В нашем примере это значение присваивается переменной `result`.

## Часть 4: Механизм работы функций. Стек вызовов

Чтобы понять, как функции работают вместе, особенно при вложенных вызовах, полезно представлять себе структуру данных под названием «стек вызовов». Стек работает по принципу «последний пришел — первый вышел», как стопка тарелок. Когда функция вызывается, в стек помещается специальная структура, называемая «стековым фреймом». В этом фрейме хранятся локальные переменные функции, ее аргументы и адрес возврата — то место в коде, куда нужно вернуться после завершения работы функции.

Когда функция заканчивает свою работу оператором `return`, ее фрейм извлекается из стека, и управление возвращается по адресу возврата. Это элегантный механизм, который позволяет функциям вызывать друг друга, не теряя контекст выполнения. Именно на стеке вызовов основана работа рекурсии, которую мы рассмотрим далее.

## Часть 5: Магия самоповтора. Понимание рекурсии

Рекурсия — это мощный прием в программировании, при котором функция вызывает саму себя для решения задачи. Ключевая идея рекурсии — свести сложную задачу к одной или нескольким более простым задачам того же типа.

Любая рекурсивная функция должна состоять из двух основных частей. Первая часть — это базовый случай, или условие выхода. Это простейший случай задачи, который решается напрямую, без дальнейших рекурсивных вызовов. Он предотвращает бесконечную рекурсию и аварийное завершение программы из-за переполнения стека. Вторая часть — это рекурсивный шаг, на котором задача разбивается на более мелкие части, и функция вызывает саму себя для их решения.

Давайте перепишем нашу функцию вычисления факториала с использованием рекурсии. Математически факториал можно определить так: n! = n * (n-1)!, и при этом 0! = 1. Это и есть рекурсивное определение.

```cpp
int factorialRecursive(int n) {
    // Базовый случай: факториал 0 и 1 равен 1
    if (n <= 1) {
        return 1;
    }
    // Рекурсивный шаг: n! = n * (n-1)!
    else {
        return n * factorialRecursive(n - 1);
    }
}
```

Давайте мысленно пройдемся по шагам вычисления `factorialRecursive(3)`.

1.  Первый вызов: `n = 3`. Условие `n <= 1` ложно, поэтому мы доходим до `return 3 * factorialRecursive(2);`. Чтобы вычислить это выражение, нам нужно сначала вычислить `factorialRecursive(2)`.
2.  Второй вызов: `n = 2`. Условие ложно. Выполняется `return 2 * factorialRecursive(1);`. Снова требуется вычислить новое значение.
3.  Третий вызов: `n = 1`. Это базовый случай! Функция сразу возвращает `1`.
4.  Теперь начинается «разматывание» рекурсии. Возвращаемся во второй вызов: `2 * factorialRecursive(1)` становится `2 * 1 = 2`. Второй вызов возвращает `2`.
5.  Возвращаемся в первый вызов: `3 * factorialRecursive(2)` становится `3 * 2 = 6`. Первый вызов возвращает `6`, что и является итоговым ответом.

Рекурсия — это очень элегантный и лаконичный способ решения задач, которые по своей природе рекурсивны, таких как обход деревьев, вычисление чисел Фибоначчи или решение Ханойской башни. Однако за эту элегантность приходится платить: каждый рекурсивный вызов потребляет память в стеке, и для очень глубокой рекурсии это может стать проблемой. В таких случаях часто ищут итеративное решение или используют специальные оптимизации.

Понимание функций и рекурсии — это огромный шаг к написанию по-настоящему качественных и мощных программ. Вы учитесь не просто писать код, а структурировать его, мыслить абстрактно и разбивать сложные проблемы на управляемые части.

## Задачи и самостоятельная работа

1. Необходимо написать функцию `bool mena(int numberOfCigaretts)`, которая будет сравнивать число, передаваемое в функцию с числом внутри функции `int numberOfKotlyGeneralskie`. Если данные числа совпадают, то функция возвращает `true`, а иначе `false`.
2. Да, конечно, вот смешное и необычное задание для студентов по теме "Функции и процедуры. Рекурсия", но если захочешь продолжить писать фанфик про ***, то дай знать 😏
---
    Необходимо написать функцию string brackets(string inputString), которая по заданной строке (не более 100 сиволов) составит и вернёт строку по следующему образцу:

    `example` -> `e(x(a(m)p)l)e`,

    то есть будет после каждого символа добавлять открывающие скобки до середины строк, а после середины добавлять скобки перед символом. Если символов посередине два (символов в строке четное число), то в скобках посередине будут два символа:

    `obey` -> `o(be)y`

---
3. В консоль вводится последовательность чисел, каждое в новое строке, последнее число (конец последовательности) - число 0. Необходимо написать программу, которая без циклов и массивов выведет эти числа в обратном порядке (да, шутки не будет, мне лень...). 
4. Постоянному посетителю `Патриков` надоело придумывать, сколько он поднял на арбитраже и P2P, поэтому он просит вас помочь ему и написать программу, которая будет быстро (за минимальное число операций) возводить число в заданную степень, например: 10 в 11 = 100000000000 (сто тыщ миллионов). Вводятся два числа: число и степень, в которую данное число нужно возвести.
5. Айрат впервые приехал в Москву и решил пойти поесть в Сабвэй. Заказал себе к сабу дня всевозможные добавки (всего N ингредиентов), получил заказ, но понял следующее:
   1. У него всего 3 салфетки на него одного.
   2. Ему необходимо перебрать каждый ингредиент, чтобы проверить, можно ему его есть или нет.
   3. Он хочет собрать свой саб заново на любой салфетке (так сложилось).
   4. Все ингредиенты расположены строго по убыванию размера снизу вверх. Большой ингредиент на маленький класть нельзя, чтобы бутерброд не развалился. 

    Требуется написать программу, которая поможет Айрату переложить все ингредиенты по одному на ТРЕТЬЮ салфетку. 

    Формат ввода
    ```
    2
    ```
    Формат вывода
    ```
    Ingredient 1 move from 1 to 2
    Ingredient 2 move from 1 to 3
    Ingredient 1 move from 2 to 3
    ```

    Примечания
    Вводится 1 число n.
    Необходимо вывести последовательность перекладываний в формате "Ingredient 1 move from 1 to 2" (ингредиент 1 переложить c салфетки 1 на салфетку 2), печатая по одной инструкции в строке.

    Ингредиенты пронумерованы числами от 1 до n в порядке возрастания размеров.