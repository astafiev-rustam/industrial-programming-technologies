# Технологии индустриального программирования
|||
|---|---|
|Направление подготовки|09.03.02 "Информационные системы и технологии"|
|Профиль|Фуллстек разработка|
|Курс, семестр|1-2, 1-3 семестры|

Ссылка на репозиторий:

https://github.com/astafiev-rustam/industrial-programming-technologies/tree/practice-1-4

# Практическое занятие №4: Условные операторы и циклы

Разберем две фундаментальные конструкции, которые заставляют наши программы "думать" и "работать" — это условные операторы и циклы. Без них любая программа была бы просто линейной последовательностью команд, которая всегда работает одинаково. Давайте постепенно погрузимся в эту тему.

## Часть 1: Принятие решений в программе (Условные операторы)

Представьте, что вы пишете программу-светофор. Ее поведение должно зависеть от текущего сигнала: если горит красный, нужно остановиться, если зеленый — можно ехать. Для таких ситуаций в C++ существуют условные операторы.

### 1.1. Оператор `if` (если)

Самый простой способ организовать ветвление — это использовать оператор `if`. Его структура интуитивно понятна и очень похожа на человеческую речь.

```cpp
if (условие) {
    // блок кода, который выполнится, если условие ИСТИННО (true)
}
```

Например, программа, проверяющая, является ли число положительным:

```cpp
int number = 10;
if (number > 0) {
    cout << "Число положительное." << endl;
}
// Программа продолжит выполнение отсюда, независимо от результата проверки.
```
В этом примере, если переменная `number` больше нуля, условие `number > 0` возвращает `true`, и сообщение выводится на экран. Если условие ложно (`false`), блок кода внутри фигурных скобок просто пропускается.

### 1.2. Расширение выбора: `if...else` (если...иначе)

Часто требуется предусмотреть не только действие на случай истинности условия, но и альтернативное действие. Для этого мы добавляем блок `else`.

```cpp
int age = 17;
if (age >= 18) {
    cout << "Доступ разрешен." << endl;
} else {
    cout << "Доступ запрещен. Вам еще нет 18 лет." << endl;
}
```
Здесь программа пойдет по одному из двух путей. Поскольку 17 меньше 18, условие `false`, поэтому выполнится блок кода внутри `else`, и на экран будет выведено сообщение о запрете доступа.

### 1.3. Множественный выбор: `else if` (иначе если)

Бывают ситуации, когда вариантов выбора больше двух. Например, нам нужно классифицировать оценку студента. Для этого мы можем выстраивать цепочки из условий с помощью `else if`.

```cpp
int score = 85;
if (score >= 90) {
    cout << "Оценка: A" << endl;
} else if (score >= 80) { // Проверяется только если первое условие false
    cout << "Оценка: B" << endl;
} else if (score >= 70) {
    cout << "Оценка: C" << endl;
} else { // Сработает, если все условия выше оказались false
    cout << "Оценка: D или ниже" << endl;
}
```
Важно понимать, как работает эта конструкция: проверка условий идет сверху вниз. Как только находится первое условие, которое истинно (`score >= 80` в нашем случае), выполняется соответствующий ему блок кода, а все последующие `else if` и `else` пропускаются. Это очень эффективно.

### 1.4. Оператор выбора `switch`

Когда нам нужно сравнить одну переменную или выражение с множеством конкретных значений, удобнее использовать оператор `switch`. Он похож на развилку с множеством указателей.

```cpp
int dayOfWeek = 3;
switch (dayOfWeek) {
    case 1:
        cout << "Понедельник" << endl;
        break; // Ключевое слово break означает выход из switch
    case 2:
        cout << "Вторник" << endl;
        break;
    case 3:
        cout << "Среда" << endl;
        break;
    // ...
    default: // Блок default выполняется, если ни один case не подошел
        cout << "Такого дня недели не существует!" << endl;
        break;
}
```
Ключевое слово `break` здесь критически важно. Если его забыть, программа продолжит выполнять все последующие блоки `case` до первого встретившегося `break` или до конца оператора `switch`. Это поведение называется "сквозное выполнение".

## Часть 2: Многократное выполнение кода (Циклы)

Теперь представим, что нам нужно вывести на экран числа от 1 до 100. Писать 100 раз `cout` неэффективно и нерационально. Для многократного выполнения одного и того же блока кода служат циклы.

### 2.1. Цикл `while` (пока)

Цикл `while` повторяет блок кода до тех пор, пока заданное условие остается истинным.

```cpp
int counter = 1; // Инициализация счетчика
while (counter <= 5) { // Условие продолжения цикла
    cout << "Счетчик равен: " << counter << endl;
    counter++; // Изменение счетчика (очень важно!)
}
```
Результат выполнения:
```
Счетчик равен: 1
Счетчик равен: 2
Счетчик равен: 3
Счетчик равен: 4
Счетчик равен: 5
```
Самая частая ошибка новичков — забыть изменить переменную, от которой зависит условие (в нашем случае `counter++`). Это приведет к созданию бесконечного цикла, который будет работать вечно, так как условие `counter <= 5` всегда будет истинным.

### 2.2. Цикл `do...while` (делай...пока)

Это немного видоизмененный вариант цикла `while`. Его главное отличие в том, что он сначала выполняет тело цикла, а потом проверяет условие. Это гарантирует, что тело цикла выполнится как минимум один раз.

```cpp
int userNumber;
do {
    cout << "Пожалуйста, введите положительное число: ";
    cin >> userNumber;
} while (userNumber <= 0); // Проверка после выполнения

cout << "Вы ввели: " << userNumber << endl;
```
Такой цикл идеален для задач, где нужно получить корректный ввод от пользователя. Мы не знаем, что он введет с первого раза, поэтому сначала запрашиваем данные, а затем проверяем их.

### 2.3. Цикл `for` (для)

Это самый распространенный и сжатый цикл, который объединяет в одной строке инициализацию, проверку условия и изменение счетчика. Его структура идеально подходит для задач с известным количеством повторений.

```cpp
for (инициализация; условие; изменение) {
    // тело цикла
}
```
Вернемся к нашей задаче вывода чисел от 1 до 5:

```cpp
for (int i = 1; i <= 5; i++) {
    cout << "i равно: " << i << endl;
}
```
Этот код абсолютно эквивалентен примеру с циклом `while`, но записан гораздо компактнее и нагляднее. Все элементы управления циклом собраны в круглых скобках в одной строке, что уменьшает вероятность забыть изменить счетчик.

### 2.4. Операторы управления циклами: `break` и `continue`

Иногда внутри цикла возникает необходимость прервать его выполнение досрочно или пропустить текущую итерацию.

*   `break`: Немедленно завершает выполнение всего цикла (или оператора `switch`), передавая управление следующей за циклом команде.
    ```cpp
    for (int i = 1; i <= 10; i++) {
        if (i == 5) {
            break; // Выход из цикла, когда i станет равно 5
        }
        cout << i << " ";
    }
    // Вывод: 1 2 3 4
    ```

*   `continue`: Немедленно прерывает выполнение *текущей итерации* цикла и переходит к следующей (к проверке условия и, если оно истинно, к следующему шагу).
    ```cpp
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            continue; // Пропускаем итерацию с числом 3
        }
        cout << i << " ";
    }
    // Вывод: 1 2 4 5
    ```

## Часть 3: Комбинирование концепций на практическом примере

Давайте напишем небольшую программу, которая использует все изученное. Эта программа будет просить пользователя вводить числа до тех пор, пока не будет введен ноль, а затем выведет сумму всех введенных положительных чисел.

```cpp
#include <iostream>
using namespace std;

int main() {
    int number;
    int sum = 0; // Инициализируем переменную для суммы

    cout << "Вводите числа. Для завершения введите 0." << endl;

    do {
        cin >> number; // Считываем число

        if (number == 0) {
            break; // Если введен 0, выходим из цикла
        }

        if (number < 0) {
            cout << "Отрицательное число пропущено." << endl;
            continue; // Пропускаем отрицательные числа
        }

        sum += number; // Добавляем положительное число к сумме

    } while (true); // Создаем условно бесконечный цикл, выход из которого через break

    cout << "Сумма введенных положительных чисел: " << sum << endl;

    return 0;
}
```
В этом примере мы видим:
*   Цикл `do...while` для организации ввода.
*   Условный оператор `if` для проверки на ноль.
*   Оператор `break` для выхода из цикла.
*   Еще один `if` для проверки на отрицательное число.
*   Оператор `continue` для пропуска итерации.
*   Накопительную переменную `sum`.

## Задачи и самостоятельная работа

Каждая задача из списка оценивается в 

1. Два молодых человек столкнулись на улице: у одного оказалось ```x``` млн. мощи, а у второго ```y``` млн. мощи. Необходимо написать программу, которая выведет результат столкновения: если x>y, то ```X```, либо ```Y``` в противном случае.

2. На концерте Ивана Золо кто-то кинул в него **неопознанный летающий объект**. Известно, откуда был осуществлён бросок (траектория - прямая линии), но неизвестно кто конкретно. Получается, что известно некоторое ```S``` - расстояние, которое пролетел предмет, его ускорение ```a``` и начальная скорость ```V0```. Зная, что все эти величины связаны с ```S``` следующим образом:

                            S = V0*t + (a*t*t)/2
    Необходимо найти t, которое понадобится, чтобы установить виновника.

3. Ваш странный одногруппник решил, что следующая его особенность сделает его не таким как все, поэтому решил, что будет пользоваться римскими числами везде в повседневной жизни. Необходимо доказать ему, что это не так сложно и написать программу, которая будет переводить некоторое число в десятичной записи (не провосходит 1000) в римскую запись.

4. Криптошейх Иван устал от P2P и арбитража, поэтому пошёл на завод по получению натуральных чисел. За станком у Вани есть только 2 кнопки: -1 (уменьшает текущее число на 1), :2 (делит текущее число на 2, если оно чётное).
    
    На экране у Ивана появляются два числа: A и B, где A > B. Он может нажимать кнопки до тех пор, пока не получит из числа A число B. Необходимо написать программу, которая будет преобразовывать число A в число B за минимальное число нажатий.

5. Двое людей приятной наружности пришли посетить магазин у дома, где разливают пенное (квас). С собой у них было две бутылки на A и B литров соответственно. Им позарез (а больше денег и нет) необходимо именно N литров пенного (кваса).

    Продавец в магазине может совершать только определнный набор операций:
    ```>A``` - заполнить до краёв сосуд A
    
    ```>B``` - заполнить до краёв сосуд B

     ```A>``` - вылить целиком содержимое сосуда A
    
     ```B>``` - вылить целиком содержимое сосуда B

     ```A>B``` - перелить содержимое сосуда A в B, пока последний не заполнится или не закончится пенное (квас) в сосуде A

    ```B>A``` - перелить содержимое сосуда B в A, пока последний не заполнится или не закончится пенное (квас) в сосуде B

    Необходимо вывести последовательность действий продавца или "mission impossible 2", если сделать это невозможно.
